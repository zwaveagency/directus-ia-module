import { Accountability, GlobalAccess, Plural } from "@directus/types";
import { Knex } from "knex";
import { Readable } from "node:stream";

//#region node/array-helpers.d.ts
declare function isIn<T extends readonly string[]>(value: string, array: T): value is T[number];
declare function isTypeIn<T extends {
  type?: string;
}, E extends string>(object: T, array: readonly E[]): object is Extract<T, {
  type?: E;
}>;
//#endregion
//#region node/fetch-global-access/fetch-global-access.d.ts
/**
 * Fetches the global access permissions for a given accountability.
 *
 * @param accountability - The accountability object containing user, roles, and optionally the IP.
 * @param context
 * @returns The global access permissions.
 */
declare function fetchGlobalAccess(accountability: Pick<Accountability, 'user' | 'roles' | 'ip'>, context: {
  knex: Knex;
}): Promise<GlobalAccess>;
//#endregion
//#region node/fetch-global-access/lib/fetch-global-access-for-roles.d.ts
/**
 * Fetches the global access permissions for specific roles.
 *
 * @param roles  - The array of role IDs
 * @param context
 * @returns - The global access permissions for the roles
 */
declare function fetchGlobalAccessForRoles(roles: Accountability['roles'], context: {
  knex: Knex;
  ip?: Accountability['ip'];
}): Promise<GlobalAccess>;
//#endregion
//#region node/fetch-global-access/lib/fetch-global-access-for-user.d.ts
/**
 * Fetches the global access permissions for a specific user.
 *
 * @param user - The user ID
 * @param context
 * @returns - The global access permissions for the user
 */
declare function fetchGlobalAccessForUser(user: Accountability['user'], context: {
  knex: Knex;
  ip?: Accountability['ip'];
}): Promise<GlobalAccess>;
//#endregion
//#region node/fetch-roles-tree.d.ts
/**
 * Given a starting role ID, fetches the entire hierarchy of roles up to the root.
 *
 * @param start - The starting role ID.
 * @param context
 * @returns An array of role IDs from root to the starting role.
 */
declare function fetchRolesTree(start: string | null, context: {
  knex: Knex;
}): Promise<string[]>;
//#endregion
//#region node/get-node-env.d.ts
/**
 * Get the configured Node Environment (eg "production", "development", etc)
 */
declare const getNodeEnv: () => string | undefined;
//#endregion
//#region node/ip-in-networks.d.ts
/**
 * Checks if an IP address is contained in a list of networks
 * @param networks List of IP addresses (192.168.0.1), CIDR notations (192.168.0.0/24) or IP ranges (192-168.0.0-192.168.2.0)
 * @throws Will throw if list contains invalid network definitions
 */
declare function ipInNetworks(ip: string, networks: string[]): boolean;
//#endregion
//#region node/is-readable-stream.d.ts
declare const isReadableStream: (input: any) => input is Readable;
//#endregion
//#region node/list-folders.d.ts
interface ListFoldersOptions {
  /**
   * Ignore folders starting with a period `.`
   */
  ignoreHidden?: boolean;
}
declare function listFolders(location: string, options?: ListFoldersOptions): Promise<string[]>;
//#endregion
//#region node/path-to-relative-url.d.ts
declare function pathToRelativeUrl(filePath: string, root?: string): string;
//#endregion
//#region node/pluralize.d.ts
declare function pluralize<T extends string>(str: T): Plural<T>;
declare function depluralize<T extends string>(str: Plural<T>): T;
//#endregion
//#region node/process-id.d.ts
declare const _cache: {
  id: string | undefined;
};
/**
 * Return a unique hash for the current process on the current machine. Will be different after a
 * restart
 */
declare const processId: () => string;
//#endregion
//#region node/readable-stream-to-string.d.ts
declare const readableStreamToString: (stream: Readable) => Promise<string>;
//#endregion
//#region node/require-yaml.d.ts
declare const requireYaml: (filepath: string) => unknown;
//#endregion
//#region node/resolve-package.d.ts
declare function resolvePackage(name: string, root?: string): string;
//#endregion
//#region node/tmp.d.ts
declare function createTmpFile(): Promise<{
  path: string;
  cleanup: () => Promise<void>;
}>;
//#endregion
export { _cache, createTmpFile, depluralize, fetchGlobalAccess, fetchGlobalAccessForRoles, fetchGlobalAccessForUser, fetchRolesTree, getNodeEnv, ipInNetworks, isIn, isReadableStream, isTypeIn, listFolders, pathToRelativeUrl, pluralize, processId, readableStreamToString, requireYaml, resolvePackage };