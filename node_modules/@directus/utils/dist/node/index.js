import { createRequire } from "node:module";
import { matches } from "ip-matching";
import fse from "fs-extra";
import path from "path";
import { createHash } from "node:crypto";
import { hostname, tmpdir } from "node:os";
import yaml from "js-yaml";
import { readFileSync } from "node:fs";
import fs from "node:fs/promises";
import { join } from "node:path";

//#region node/array-helpers.ts
function isIn(value, array) {
	return array.includes(value);
}
function isTypeIn(object, array) {
	if (!object.type) return false;
	return array.includes(object.type);
}

//#endregion
//#region shared/to-array.ts
function toArray(val) {
	if (typeof val === "string") return val.split(",");
	return Array.isArray(val) ? val : [val];
}

//#endregion
//#region shared/to-boolean.ts
/**
* Convert environment variable to Boolean
*/
function toBoolean(value) {
	return value === "true" || value === true || value === "1" || value === 1;
}

//#endregion
//#region node/ip-in-networks.ts
/**
* Checks if an IP address is contained in a list of networks
* @param networks List of IP addresses (192.168.0.1), CIDR notations (192.168.0.0/24) or IP ranges (192-168.0.0-192.168.2.0)
* @throws Will throw if list contains invalid network definitions
*/
function ipInNetworks(ip, networks) {
	for (const allowedIp of networks) if (matches(ip, allowedIp)) return true;
	return false;
}

//#endregion
//#region node/fetch-global-access/utils/fetch-global-access-for-query.ts
async function fetchGlobalAccessForQuery(query, accountability) {
	const globalAccess = {
		app: false,
		admin: false
	};
	const accessRows = await query.select("directus_policies.admin_access", "directus_policies.app_access", "directus_policies.ip_access").from("directus_access").leftJoin("directus_policies", "directus_policies.id", "directus_access.policy");
	for (const { admin_access, app_access, ip_access } of accessRows) {
		if (accountability.ip && ip_access) {
			const networks = toArray(ip_access);
			if (!ipInNetworks(accountability.ip, networks)) continue;
		}
		globalAccess.admin ||= toBoolean(admin_access);
		globalAccess.app ||= globalAccess.admin || toBoolean(app_access);
		if (globalAccess.admin) break;
	}
	return globalAccess;
}

//#endregion
//#region node/fetch-global-access/lib/fetch-global-access-for-roles.ts
/**
* Fetches the global access permissions for specific roles.
*
* @param roles  - The array of role IDs
* @param context
* @returns - The global access permissions for the roles
*/
async function fetchGlobalAccessForRoles(roles, context) {
	return await fetchGlobalAccessForQuery(context.knex.where("role", "in", roles), { ip: context.ip ?? null });
}

//#endregion
//#region node/fetch-global-access/lib/fetch-global-access-for-user.ts
/**
* Fetches the global access permissions for a specific user.
*
* @param user - The user ID
* @param context
* @returns - The global access permissions for the user
*/
async function fetchGlobalAccessForUser(user, context) {
	return await fetchGlobalAccessForQuery(context.knex.where("user", "=", user), { ip: context.ip ?? null });
}

//#endregion
//#region node/fetch-global-access/fetch-global-access.ts
/**
* Fetches the global access permissions for a given accountability.
*
* @param accountability - The accountability object containing user, roles, and optionally the IP.
* @param context
* @returns The global access permissions.
*/
async function fetchGlobalAccess(accountability, context) {
	const access = await fetchGlobalAccessForRoles(accountability.roles, {
		knex: context.knex,
		ip: accountability.ip
	});
	if (accountability.user !== void 0) {
		const userAccess = await fetchGlobalAccessForUser(accountability.user, {
			knex: context.knex,
			ip: accountability.ip
		});
		access.app ||= userAccess.app;
		access.admin ||= userAccess.admin;
	}
	return access;
}

//#endregion
//#region node/fetch-roles-tree.ts
/**
* Given a starting role ID, fetches the entire hierarchy of roles up to the root.
*
* @param start - The starting role ID.
* @param context
* @returns An array of role IDs from root to the starting role.
*/
async function fetchRolesTree(start, context) {
	if (!start) return [];
	let parent = start;
	const roles = [];
	const { knex } = context;
	while (parent) {
		const role = await knex.select("id", "parent").from("directus_roles").where({ id: parent }).first();
		if (!role) break;
		roles.push(role.id);
		if (role.parent && roles.includes(role.parent) === true) {
			roles.reverse();
			const rolesStr = roles.map((role$1) => `"${role$1}"`).join("->");
			throw new Error(`Recursion encountered: role "${role.id}" already exists in tree path ${rolesStr}`);
		}
		parent = role.parent;
	}
	roles.reverse();
	return roles;
}

//#endregion
//#region node/get-node-env.ts
/**
* Get the configured Node Environment (eg "production", "development", etc)
*/
const getNodeEnv = () => process.env["NODE_ENV"];

//#endregion
//#region node/is-readable-stream.ts
const isReadableStream = (input) => {
	return input !== null && typeof input === "object" && typeof input.pipe === "function" && typeof input._read === "function" && typeof input._readableState === "object" && input.readable !== false;
};

//#endregion
//#region node/list-folders.ts
async function listFolders(location, options) {
	const fullPath = path.resolve(location);
	const files = await fse.readdir(fullPath);
	const directories = [];
	for (const file of files) {
		if (options?.ignoreHidden && file.startsWith(".")) continue;
		const filePath = path.join(fullPath, file);
		if ((await fse.stat(filePath)).isDirectory()) directories.push(file);
	}
	return directories;
}

//#endregion
//#region node/path-to-relative-url.ts
function pathToRelativeUrl(filePath, root = ".") {
	return path.relative(root, filePath).split(path.sep).join(path.posix.sep);
}

//#endregion
//#region node/pluralize.ts
function pluralize(str) {
	return `${str}s`;
}
function depluralize(str) {
	return str.slice(0, -1);
}

//#endregion
//#region node/process-id.ts
const _cache = { id: void 0 };
/**
* Return a unique hash for the current process on the current machine. Will be different after a
* restart
*/
const processId = () => {
	if (_cache.id) return _cache.id;
	const parts = [
		hostname(),
		process.pid,
		(/* @__PURE__ */ new Date()).getTime()
	];
	_cache.id = createHash("md5").update(parts.join("")).digest("hex");
	return _cache.id;
};

//#endregion
//#region node/readable-stream-to-string.ts
const readableStreamToString = async (stream) => {
	const chunks = [];
	for await (const chunk of stream) chunks.push(Buffer.from(chunk));
	return Buffer.concat(chunks).toString("utf8");
};

//#endregion
//#region node/require-yaml.ts
const requireYaml = (filepath) => {
	const yamlRaw = readFileSync(filepath, "utf8");
	return yaml.load(yamlRaw);
};

//#endregion
//#region node/resolve-package.ts
const require = createRequire(import.meta.url);
function resolvePackage(name, root) {
	return path.dirname(require.resolve(`${name}/package.json`, root !== void 0 ? { paths: [root] } : void 0));
}

//#endregion
//#region node/tmp.ts
async function createTmpDirectory() {
	const path$1 = await fs.mkdtemp(join(tmpdir(), "directus-"));
	async function cleanup() {
		return await fs.rmdir(path$1);
	}
	return {
		path: path$1,
		cleanup
	};
}
async function createTmpFile() {
	const dir = await createTmpDirectory();
	const filename = createHash("sha1").update((/* @__PURE__ */ new Date()).toString()).digest("hex").substring(0, 8);
	const path$1 = join(dir.path, filename);
	try {
		await (await fs.open(path$1, "wx")).close();
	} catch (err) {
		await dir.cleanup();
		throw err;
	}
	async function cleanup() {
		await fs.unlink(path$1);
		await dir.cleanup();
	}
	return {
		path: path$1,
		cleanup
	};
}

//#endregion
export { _cache, createTmpFile, depluralize, fetchGlobalAccess, fetchGlobalAccessForRoles, fetchGlobalAccessForUser, fetchRolesTree, getNodeEnv, ipInNetworks, isIn, isReadableStream, isTypeIn, listFolders, pathToRelativeUrl, pluralize, processId, readableStreamToString, requireYaml, resolvePackage };